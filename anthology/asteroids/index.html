<!DOCTYPE html>
<html>
<head>
    <title>Asteroids Game with Enemy Ships and Sound</title>
    <style>
        /* Importing Google Fonts - Press Start 2P for a retro 80s vibe */
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        /* Overall page styling */
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            font-family: 'Press Start 2P', sans-serif;
            color: #00FF00; /* CRT Green */
            text-align: center;
        }

        /* Canvas styling */
        canvas {
            background-color: #000;
            display: block;
            margin: 0 auto;
        }

        /* Story text styling */
        #storyText {
            max-width: 800px;
            margin: 20px auto;
            line-height: 1.5;
            color: #00FF00; /* CRT Green */
            white-space: pre-wrap; /* Preserves whitespace and line breaks */
        }

        /* Story instructions styling */
        #storyInstructions {
            margin-top: 20px;
            color: #00FF00; /* CRT Green */
            font-size: 18px;
        }

        /* Additional styling for the container */
        .game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        /* Flicker effect for story */
        .flicker {
            animation: flicker 1.5s infinite alternate;
        }

        @keyframes flicker {
            0% { opacity: 1; }
            50% { opacity: 0.8; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
<div class="game-container">
    <h1>Asteroids Game</h1>
    <div id="storyText">
        <!-- Story content will be injected here -->
        <div id="storyInstructions">[ Press Spacebar ] [ S to Skip ]</div>
    </div>
    <canvas id="gameCanvas" width="800" height="600" style="display: none;"></canvas>

    <!-- Include audio elements -->
    <audio id="ambientSound" loop>
        <source src="../../public/s/ambient.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    <audio id="laserSound">
        <source src="../../public/s/laser.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    <audio id="explosionSound">
        <source src="../../public/s/explosion.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    <audio id="shipExplosionSound">
        <source src="../../public/s/ship_explosion.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    <audio id="shipBridgeSound" loop>
        <source src="../../public/s/bridge.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    <!-- Optional: Enemy ship shooting sound -->
    <audio id="enemyLaserSound">
        <source src="../../public/s/enemy-laser.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
</div>

<script>
    // Get canvas and context
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const storyTextDiv = document.getElementById('storyText');
    const storyInstructionsDiv = document.getElementById('storyInstructions'); // Added instructions div

    // Get audio elements
    const ambientSound = document.getElementById('ambientSound');
    const laserSound = document.getElementById('laserSound');
    const bridgeSound = document.getElementById('shipBridgeSound');
    const explosionSound = document.getElementById('explosionSound');
    const shipExplosionSound = document.getElementById('shipExplosionSound');
    const enemyLaserSound = document.getElementById('enemyLaserSound'); // Optional

    // Color constants
    const CRT_GREEN = '#00FF00';
    const CRT_RED = '#FF0000'; // Bright red color
    const CRT_PURPLE = '#FF00FF'; // Purple for enemy bullets
    const AMBER = '#FFBF00';
    const CRT_BLUE = '#00BFFF';

    // Game variables
    let ship;
    let asteroids = [];
    let bullets = [];
    let enemyShips = []; // Array to hold enemy ships
    let enemyBullets = []; // Array to hold enemy bullets
    let explosions = [];
    let blobs = []; // Array to hold blobs
    let keys = {};
    let round = 1;
    let inStoryMode = true;
    let currentStoryPage = 0;
    let shipDestroyed = false;
    const blobStartRound = 6; // Configure the round to start enemy ships
    const enemyShipStartRound = 3; // Configure the round to start enemy ships
    const enemyBaseStartRound = 4; // Configure the round to start enemy ships
    const maxEnemyShips = 5; // Maximum number of enemy ships allowed

    // Story arrays
    const stories = [
        // Round 1 Story
        [
            "Captain Rex: \"This is Rex, reporting in from sector 7G. All systems are nominal.\"",
            "Space Command: \"Copy that, Captain. Any sign of the fugitives?\"",
            "Captain Rex: \"Not yet. They've gone quiet since entering this region.\"",
            "Space Command: \"Be advised, you're approaching uncharted territory.\"",
            "Captain Rex: \"Understood. The star density is increasing. Proceeding with caution.\"",
            "Space Command: \"Our sensors indicate possible asteroid fields ahead.\"",
            "Captain Rex: \"Affirmative. I'm starting to pick up asteroids on the radar.\"",
            "Space Command: \"Maintain vigilance. The fugitives might be hiding out there.\"",
            "Captain Rex: \"Will do. Nothing untoward so far, but I'll stay sharp.\"",
            "Space Command: \"We're counting on you, Captain. Begin your sweep when ready.\""
        ],
        // Round 2 Story
        [
            "Captain Rex: \"Space Command, do you read? I'm noticing unusual readings.\"",
            "Space Command: \"...tain...x... signal...weak...\"",
            "Captain Rex: \"Repeat that, Command. You're breaking up.\"",
            "Static fills the channel, and Rex hears faint, distorted voices.",
            "Captain Rex: \"Something's not right here. Systems are acting up.\"",
            "He checks his instruments, which flicker erratically.",
            "Captain Rex: \"Is anyone there? Respond!\"",
            "The only reply is garbled noise and intermittent silence.",
            "A sense of unease settles in as the asteroid field grows denser.",
            "Captain Rex grips the controls tighter: \"I have a bad feeling about this...\""
        ],
        // Round 3 Story
        [
            "Captain Rex: \"Enemy ships detected! They're engaging our position.\"",
            "Space Command: \"Understood, Captain. Engage them with all available weapons.\"",
            "Captain Rex: \"Firing lasers! Taking heavy fire in return.\"",
            "Space Command: \"Be cautious, Rex. They seem organized and relentless.\"",
            "Captain Rex: \"Affirmative. Maneuvering to evade incoming fire.\"",
            "Enemy ships are closing in, attempting to outflank our position.",
            "Captain Rex: \"They're forming a pincer move. Need to break their formation.\"",
            "Space Command: \"Use the asteroid fields as cover. It might give you the advantage.\"",
            "Captain Rex: \"Good idea. Diving into the nearest asteroid to hide our movements.\"",
            "Space Command: \"Stay sharp, Captain. The enemy isn't giving up easily.\""
        ],
        // Round 4 Story
        [
            "Captain Rex: \"Some of these asteroids are housing enemy weapons outposts.\"",
            "Space Command: \"Be careful, Rex. Those outposts are heavily fortified.\"",
            "Captain Rex: \"Engaging the outpost's defenses. It's more challenging than anticipated.\"",
            "Space Command: \"Deploy additional firepower if you can. We can't let them bolster their arsenal.\"",
            "Captain Rex: \"Understood. Launching missiles towards the enemy outpost.\"",
            "The outpost retaliates with concentrated energy blasts.",
            "Captain Rex: \"Taking heavy fire. Shields are holding for now.\"",
            "Space Command: \"Maintain your assault, Captain. We need to cripple their operations.\"",
            "Captain Rex: \"Shields are holding, but the hull integrity is compromised.\"",
            "Space Command: \"Proceed with caution. Your safety is our priority.\""
        ],
        // Round 5 Story
        [
            "Captain Rex: \"Taking heavy fire from enemy reinforcements. There are almost too many.\"",
            "Space Command: \"Rex, hold your ground. We are dispatching additional support.\"",
            "Captain Rex: \"Enemy numbers are overwhelming. Our defenses are stretched thin.\"",
            "Space Command: \"Maintain your position. Reinforcements should arrive shortly.\"",
            "Captain Rex: \"Enemy ships are relentless. It's like they're anticipating our every move.\"",
            "Space Command: \"They must have intelligence on our patrol routes. Stay alert.\"",
            "Captain Rex: \"Using evasive maneuvers to confuse the enemy. It's only buying us time.\"",
            "Space Command: \"Reinforcements are en route. Hold out as long as you can.\"",
            "Captain Rex: \"Understood. Preparing for a coordinated defense.\"",
            "Space Command: \"Good luck, Captain. We're all counting on you.\""
        ],
        // Round 6 Story
        [
            "Captain Rex: \"The enemy is well-prepared. Their tactics are superior to ours.\"",
            "Space Command: \"Adjust your strategy, Rex. Adapt to their movements.\"",
            "Captain Rex: \"Affirmative. Changing formation to counter their assault.\"",
            "Enemy ships are deploying advanced weaponry and coordinated attacks.",
            "Captain Rex: \"Their flagship has appeared. It’s directing their forces.\"",
            "Space Command: \"Focus your fire on the flagship. Neutralizing it could disorient the enemy.\"",
            "Captain Rex: \"Targeting the flagship now. Preparing to launch heavy ordnance.\"",
            "The flagship retaliates with a devastating energy beam.",
            "Captain Rex: \"Incoming beam! Evading at maximum speed.\"",
            "Space Command: \"Hold steady, Captain. Aim for the flagship's weak points.\""
        ],
        // Round 7 Story
        [
            "Captain Rex: \"What the hell was that? It was some sort of translucent goo? Glowing bright green and destroying everything it touches.\"",
            "Space Command: \"Unknown substance detected. It appears to be a form of energy-based weapon.\"",
            "Captain Rex: \"It's spreading rapidly, compromising our systems and hull integrity.\"",
            "Space Command: \"Attempt to contain the spread. Use your shield generators to create barriers.\"",
            "Captain Rex: \"Shields are fluctuating. The goo is disrupting our systems.\"",
            "Space Command: \"Deploy anti-viral protocols to purge the contamination.\"",
            "Captain Rex: \"Engaging protocols now. The goo is resisting our containment efforts.\"",
            "Space Command: \"Fallback to emergency protocols. We need to stabilize the ship.\"",
            "Captain Rex: \"Stabilizing ship's core. The contamination is slowing down.\"",
            "Space Command: \"Good work, Captain. Continue to monitor for any further anomalies.\""
        ],
        // Round 8 Story
        [
            "Captain Rex: \"Something is happening. Where are all these asteroids coming from?\"",
            "Space Command: \"Analyzing data... It appears to be a coordinated deployment from multiple sectors.\"",
            "Captain Rex: \"This is unprecedented. The asteroid density is off the charts.\"",
            "Space Command: \"Rex, it seems the enemy is using advanced technology to manipulate the asteroid fields.\"",
            "Captain Rex: \"If they control the asteroids, they can ambush us at any point.\"",
            "Space Command: \"We need to disrupt their control mechanisms. Focus on disabling their satellites.\"",
            "Captain Rex: \"Understood. Scanning for satellite installations within the asteroid clusters.\"",
            "Space Command: \"Proceed with caution. These installations are likely heavily guarded.\"",
            "Captain Rex: \"Engaging enemy satellites. It’s a tough battle, but we must persevere.\"",
            "Space Command: \"Stay focused, Captain. The fate of the sector depends on your success.\""
        ],
        // Round 9 Story
        [
            "Captain Rex: \"Space Command, what's going on? Has something happened? There are too many asteroids.\"",
            "Space Command: \"Affirmative, Rex. We're detecting multiple large-scale disruptions across sectors.\"",
            "Captain Rex: \"It’s like a cosmic storm. The asteroids are accelerating towards our position.\"",
            "Space Command: \"Rex, initiate emergency protocols. We need to find a safe passage out of the asteroid belt.\"",
            "Captain Rex: \"I'm trying to map a path, but the debris is too dense. It's impeding our navigation systems.\"",
            "Space Command: \"Divert power to the navigation thrusters. We might be able to create a temporary corridor.\"",
            "Captain Rex: \"Diverting power now. Attempting to create a pathway through the debris.\"",
            "Space Command: \"Be cautious. The debris fields are unstable and unpredictable.\"",
            "Captain Rex: \"Pathway is partially clear, but the engines are struggling against the debris.\"",
            "Space Command: \"Maintain your course, Captain. Reinforcements are being deployed to assist you.\""
        ],
        // Round 10 Story
        [
            "Captain Rex: \"I can't find a path out. Where did all this debris come from? Space Command, I'm not gonna make it.\"",
            "Space Command: \"Rex, hold on! We're deploying a rescue team immediately.\"",
            "Captain Rex: \"The ship's integrity is failing. The debris is tearing us apart.\"",
            "Space Command: \"Initiate self-destruct protocols to prevent enemy capture.\"",
            "Captain Rex: \"Understood. Preparing to self-destruct.\"",
            "The ship starts to power down, systems failing one by one.",
            "Captain Rex: \"It's been an honor serving with you, Command. Take care of our sector.\"",
            "Space Command: \"Rex, stay strong! We're on our way to extract you.\"",
            "Captain Rex: \"There's too much debris. I don't see any escape routes.\"",
            "Space Command: \"Rex, don't give up! Reinforcements are almost here. Hang in there!\""
        ]
    ];


    // Ship class
    class Ship {
        constructor() {
            this.x = canvas.width / 2;
            this.y = canvas.height / 2;
            this.radius = 15;
            this.angle = 0;
            this.rotation = 0;
            this.thrust = {
                x: 0,
                y: 0
            };
            this.acceleration = 0.1;
            this.friction = 0.99;
            this.alive = true;
        }

        update() {
            if (this.alive) {
                // Rotate ship
                this.angle += this.rotation;

                // Move ship
                if (keys['ArrowUp']) {
                    this.thrust.x += this.acceleration * Math.cos(this.angle);
                    this.thrust.y += this.acceleration * Math.sin(this.angle);
                } else {
                    // Apply friction
                    this.thrust.x *= this.friction;
                    this.thrust.y *= this.friction;
                }

                this.x += this.thrust.x;
                this.y += this.thrust.y;

                // Screen edges
                if (this.x < 0) this.x = canvas.width;
                if (this.x > canvas.width) this.x = 0;
                if (this.y < 0) this.y = canvas.height;
                if (this.y > canvas.height) this.y = 0;
            }
        }

        draw() {
            if (this.alive) {
                ctx.lineWidth = 2;
                const frontX = this.x + this.radius * Math.cos(this.angle);
                const frontY = this.y + this.radius * Math.sin(this.angle);
                const leftX = this.x + this.radius * Math.cos(this.angle + 2 * Math.PI / 3);
                const leftY = this.y + this.radius * Math.sin(this.angle + 2 * Math.PI / 3);
                const rightX = this.x + this.radius * Math.cos(this.angle + 4 * Math.PI / 3);
                const rightY = this.y + this.radius * Math.sin(this.angle + 4 * Math.PI / 3);

                // Front line (front tip to right back point) - CRT_BLUE
                ctx.beginPath();
                ctx.moveTo(frontX, frontY);
                ctx.lineTo(rightX, rightY);
                ctx.strokeStyle = CRT_BLUE;
                ctx.stroke();

                // Right back line (right back point to left back point) - CRT_GREEN
                ctx.beginPath();
                ctx.moveTo(rightX, rightY);
                ctx.lineTo(leftX, leftY);
                ctx.strokeStyle = CRT_GREEN;
                ctx.stroke();

                // Left back line (left back point to front tip) - CRT_BLUE
                ctx.beginPath();
                ctx.moveTo(leftX, leftY);
                ctx.lineTo(frontX, frontY);
                ctx.strokeStyle = CRT_BLUE;
                ctx.stroke();
            }
        }
    }

    // Asteroid class
    class Asteroid {
        constructor(x, y, radius, level, color = CRT_GREEN) { // Default color is green
            this.x = x;
            this.y = y;
            this.radius = radius;
            this.level = level;
            this.color = color; // New property for color
            this.angle = Math.random() * Math.PI * 2;
            this.speed = Math.random() * 1.5 + 0.5;
            this.vx = Math.cos(this.angle) * this.speed;
            this.vy = Math.sin(this.angle) * this.speed;
            this.vertices = Math.floor(Math.random() * 5 + 5);
            this.offset = [];

            for (let i = 0; i < this.vertices; i++) {
                this.offset.push(Math.random() * this.radius / 2 - this.radius / 4);
            }

            // Shooting properties
            this.shootInterval = Math.floor(Math.random() * 200 + 100); // Frames between shots
            this.shootTimer = 0;
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;

            // Screen edges - wrap around
            if (this.x < -this.radius) this.x = canvas.width + this.radius;
            if (this.x > canvas.width + this.radius) this.x = -this.radius;
            if (this.y < -this.radius) this.y = canvas.height + this.radius;
            if (this.y > canvas.height + this.radius) this.y = -this.radius;

            // Handle shooting
            if (round >= enemyBaseStartRound && this.color === CRT_RED) {
                this.shootTimer++;
                if (this.shootTimer >= this.shootInterval) {
                    this.shoot();
                    this.shootTimer = 0;
                    // Randomize the next shoot interval
                    this.shootInterval = Math.floor(Math.random() * 200 + 100);
                }
            }
        }

        shoot() {
            // Calculate angle towards the ship
            const angleToShip = Math.atan2(ship.y - this.y, ship.x - this.x);
            enemyBullets.push(new EnemyBullet(this.x, this.y, angleToShip));

            // Play enemy shooting sound
            if (enemyLaserSound) {
                enemyLaserSound.currentTime = 0;
                enemyLaserSound.play().catch(error => {
                    console.error("Enemy laser sound playback failed:", error);
                });
            }
        }

        draw() {
            ctx.strokeStyle = this.color; // Use the asteroid's color
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < this.vertices; i++) {
                const angle = ((Math.PI * 2) / this.vertices) * i;
                const r = this.radius + this.offset[i];
                const x = this.x + r * Math.cos(angle);
                const y = this.y + r * Math.sin(angle);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            ctx.stroke();
        }
    }

    // Enemy Ship class
    class EnemyShip {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.radius = 20; // Size of the enemy ship
            this.angle = Math.random() * Math.PI * 2;
            this.speed = Math.random() * 1 + 0.5; // Speed between 0.5 and 1.5
            this.vx = Math.cos(this.angle) * this.speed;
            this.vy = Math.sin(this.angle) * this.speed;
            this.color = CRT_RED; // Enemy ship color
            this.shootInterval = Math.floor(Math.random() * 300 + 200); // Frames between shots
            this.shootTimer = 0;
        }

        update() {
            // Move the enemy ship
            this.x += this.vx;
            this.y += this.vy;

            // Wrap around screen edges
            if (this.x < -this.radius) this.x = canvas.width + this.radius;
            if (this.x > canvas.width + this.radius) this.x = -this.radius;
            if (this.y < -this.radius) this.y = canvas.height + this.radius;
            if (this.y > canvas.height + this.radius) this.y = -this.radius;

            // Handle shooting
            this.shootTimer++;
            if (this.shootTimer >= this.shootInterval) {
                this.shoot();
                this.shootTimer = 0;
                // Randomize the next shoot interval
                this.shootInterval = Math.floor(Math.random() * 300 + 200);
            }
        }

        shoot() {
            // Calculate angle towards the player's ship
            const angleToPlayer = Math.atan2(ship.y - this.y, ship.x - this.x);
            enemyBullets.push(new EnemyBullet(this.x, this.y, angleToPlayer));

            // Play enemy shooting sound
            if (enemyLaserSound) {
                enemyLaserSound.currentTime = 0;
                enemyLaserSound.play().catch(error => {
                    console.error("Enemy laser sound playback failed:", error);
                });
            }
        }


        draw() {
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            // Simple triangle shape for the enemy ship
            const frontX = this.x + this.radius * Math.cos(this.angle);
            const frontY = this.y + this.radius * Math.sin(this.angle);
            const leftX = this.x + this.radius * Math.cos(this.angle + (5 * Math.PI) / 6);
            const leftY = this.y + this.radius * Math.sin(this.angle + (5 * Math.PI) / 6);
            const rightX = this.x + this.radius * Math.cos(this.angle - (5 * Math.PI) / 6);
            const rightY = this.y + this.radius * Math.sin(this.angle - (5 * Math.PI) / 6);

            ctx.moveTo(frontX, frontY);
            ctx.lineTo(leftX, leftY);
            ctx.lineTo(rightX, rightY);
            ctx.closePath();
            ctx.stroke();
        }

    }

    // Bullet class
    class Bullet {
        constructor(x, y, angle) {
            this.x = x;
            this.y = y;
            this.angle = angle;
            this.speed = 5;
            this.radius = 2;
            this.color = CRT_BLUE;
            this.life = 0;
            this.maxLife = 60;
        }

        update() {
            this.x += this.speed * Math.cos(this.angle);
            this.y += this.speed * Math.sin(this.angle);

            // Screen edges - wrap around
            if (this.x < 0) this.x = canvas.width;
            if (this.x > canvas.width) this.x = 0;
            if (this.y < 0) this.y = canvas.height;
            if (this.y > canvas.height) this.y = 0;

            this.life++;
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // Enemy Bullet class
    class EnemyBullet {
        constructor(x, y, angle) {
            this.x = x;
            this.y = y;
            this.angle = angle;
            this.speed = 4; // Slightly faster than player's bullets
            this.radius = 3;
            this.color = CRT_PURPLE; // Color of enemy bullets
            this.life = 0;
            this.maxLife = 120; // Lifespan of enemy bullets
        }

        update() {
            this.x += this.speed * Math.cos(this.angle);
            this.y += this.speed * Math.sin(this.angle);

            // Screen edges - wrap around
            if (this.x < 0) this.x = canvas.width;
            if (this.x > canvas.width) this.x = 0;
            if (this.y < 0) this.y = canvas.height;
            if (this.y > canvas.height) this.y = 0;

            this.life++;
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // Explosion particle class
    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.radius = Math.random() * 2 + 1;
            this.speed = Math.random() * 2 + 1;
            this.angle = Math.random() * Math.PI * 2;
            this.life = 0;
            this.maxLife = 50;
            this.color = color;
        }

        update() {
            this.x += this.speed * Math.cos(this.angle);
            this.y += this.speed * Math.sin(this.angle);
            this.life++;
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // Blob class
    class Blob {
        constructor(x, y, radius) {
            this.x = x;
            this.y = y;
            this.radius = radius || 15; // Default radius
            this.speed = Math.random() * 2 + 1; // Random speed between 1 and 3
            this.angle = Math.random() * Math.PI * 2; // Random direction
            this.vx = this.speed * Math.cos(this.angle);
            this.vy = this.speed * Math.sin(this.angle);
            this.color = '#00FF00'; // Fel Magic Green
        }

        update() {
            // Move the blob
            this.x += this.vx;
            this.y += this.vy;

            // Wrap around screen edges
            if (this.x < -this.radius) this.x = canvas.width + this.radius;
            if (this.x > canvas.width + this.radius) this.x = -this.radius;
            if (this.y < -this.radius) this.y = canvas.height + this.radius;
            if (this.y > canvas.height + this.radius) this.y = -this.radius;
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // Initialize game
    function init() {
        ship = new Ship();
        shipDestroyed = false;

        // Create initial asteroids and blobs
        createAsteroids(round);
        if (round >= blobStartRound) {
            createBlobs( round % 2 ); // Create blobs based on the round
        }

        // Create enemy ships if the round is greater than or equal to the start round
        if (round >= enemyShipStartRound) {
            createEnemyShips(round % 2); // For example, create 2 enemy ships
        }

        // Display the story
        inStoryMode = true;
        currentStoryPage = 0;
        displayStory();

        // Event listeners
        document.addEventListener('keydown', keyDown);
        document.addEventListener('keyup', keyUp);

        // Start game loop
        gameLoop();
    }

    // Function to create asteroids based on round
    function createAsteroids(num) {
        for (let i = 0; i < num; i++) {
            let x, y;
            do {
                x = Math.random() * canvas.width;
                y = Math.random() * canvas.height;
            } while (distanceBetweenPoints(ship.x, ship.y, x, y) < 100);

            // Determine asteroid color
            let color = CRT_GREEN; // Default color
            const redAsteroidChance = 0.01; // 1% chance for red asteroid
            if (round >= enemyBaseStartRound && Math.random() < redAsteroidChance) {
                color = CRT_RED;
            }

            asteroids.push(new Asteroid(x, y, 50, 1, color));
        }
    }

    // Function to create blobs based on round
    function createBlobs(num) {
        for (let i = 0; i < num; i++) {
            let x, y;
            do {
                x = Math.random() * canvas.width;
                y = Math.random() * canvas.height;
            } while (distanceBetweenPoints(ship.x, ship.y, x, y) < 100);
            blobs.push(new Blob(x, y, 15)); // Radius 15 for visibility
        }
    }

    // Function to create enemy ships based on round
    function createEnemyShips(num) {
        for (let i = 0; i < num; i++) {
            if (enemyShips.length >= maxEnemyShips) break; // Prevent overcrowding
            let x, y;
            do {
                x = Math.random() * canvas.width;
                y = Math.random() * canvas.height;
            } while (distanceBetweenPoints(ship.x, ship.y, x, y) < 150); // Ensure enemy ships don't spawn too close to the player's ship
            enemyShips.push(new EnemyShip(x, y));
            console.log(`Enemy Ship ${i + 1} created at (${x.toFixed(2)}, ${y.toFixed(2)})`);
        }
    }

    // Function to display the story
    function displayStory() {
        if (currentStoryPage === 0) {
            storyTextDiv.innerHTML = ''; // Clear previous story content
            storyTextDiv.style.display = 'block'; // Ensure story text is visible
            storyInstructionsDiv.style.display = 'block'; // Show instructions
        }

        if (stories[round - 1] && stories[round - 1][currentStoryPage]) {
            // Create a new div for the story line
            const lineDiv = document.createElement('div');
            lineDiv.textContent = stories[round - 1][currentStoryPage];
            storyTextDiv.appendChild(lineDiv);
            currentStoryPage++;
        } else {
            // No more story pages, start the round
            inStoryMode = false;
            storyTextDiv.style.display = 'none';
            storyInstructionsDiv.style.display = 'none'; // Hide instructions
            canvas.style.display = 'block';

            // Play ambient sound
            ambientSound.currentTime = 0;
            ambientSound.play().catch(error => {
                console.error("Ambient sound playback failed:", error);
            });
        }
    }

    // Game loop
    function gameLoop() {
        if (!inStoryMode) {
            // Update
            update();

            // Draw
            draw();
        }

        // Loop
        requestAnimationFrame(gameLoop);
    }

    function update() {
        ship.update();

        // Rotate ship
        if (ship.alive) {
            if (keys['ArrowLeft']) {
                ship.rotation = -0.05;
                playBridgeSound();
            } else if (keys['ArrowRight']) {
                ship.rotation = 0.05;
                playBridgeSound();
            } else {
                ship.rotation = 0;
                stopBridgeSound();
            }
        } else {
            ship.rotation = 0;
            stopBridgeSound();
        }

        // Bullets
        bullets.forEach((bullet, index) => {
            bullet.update();
            if (bullet.life > bullet.maxLife) {
                bullets.splice(index, 1);
            }
        });

        // Asteroids
        asteroids.forEach((asteroid) => {
            asteroid.update();
        });

        // Blobs
        blobs.forEach((blob) => {
            blob.update();
        });

        // Enemy Ships
        enemyShips.forEach((enemyShip) => {
            enemyShip.update();
        });

        // Enemy Bullets
        enemyBullets.forEach((enemyBullet, index) => {
            enemyBullet.update();
            if (enemyBullet.life > enemyBullet.maxLife) {
                enemyBullets.splice(index, 1);
            }
        });

        // Explosions
        explosions.forEach((explosion, index) => {
            explosion.update();
            if (explosion.life > explosion.maxLife) {
                explosions.splice(index, 1);
            }
        });

        // Collision detection
        if (ship.alive) {
            // Ship collision with asteroids
            asteroids.forEach((asteroid, aIndex) => {
                if (
                    distanceBetweenPoints(ship.x, ship.y, asteroid.x, asteroid.y) <
                    ship.radius + asteroid.radius
                ) {
                    handleShipDestruction();
                }
            });

            // Ship collision with blobs
            blobs.forEach((blob) => {
                if (
                    distanceBetweenPoints(ship.x, ship.y, blob.x, blob.y) <
                    ship.radius + blob.radius
                ) {
                    handleShipDestruction();
                }
            });

            // Ship collision with enemy bullets
            enemyBullets.forEach((enemyBullet, ebIndex) => {
                if (
                    distanceBetweenPoints(ship.x, ship.y, enemyBullet.x, enemyBullet.y) <
                    ship.radius + enemyBullet.radius
                ) {
                    // Destroy the ship
                    handleShipDestruction();

                    // Remove the enemy bullet
                    enemyBullets.splice(ebIndex, 1);
                }
            });

            // Ship collision with enemy ships
            enemyShips.forEach((enemyShip, esIndex) => {
                if (
                    distanceBetweenPoints(ship.x, ship.y, enemyShip.x, enemyShip.y) <
                    ship.radius + enemyShip.radius
                ) {
                    handleShipDestruction();

                    // Remove the enemy ship upon collision
                    enemyShips.splice(esIndex, 1);
                }
            });
        }

        // Bullets and asteroids collision
        bullets.forEach((bullet, bIndex) => {
            asteroids.forEach((asteroid, aIndex) => {
                if (
                    distanceBetweenPoints(bullet.x, bullet.y, asteroid.x, asteroid.y) <
                    asteroid.radius
                ) {
                    bullets.splice(bIndex, 1);

                    // Play explosion sound
                    explosionSound.currentTime = 0;
                    explosionSound.play().catch(error => {
                        console.error("Explosion sound playback failed:", error);
                    });

                    // Create explosion
                    createExplosion(asteroid.x, asteroid.y, asteroid.radius, CRT_GREEN);

                    // Split asteroid
                    if (asteroid.level < 3) {
                        let newRadius = asteroid.radius / 2;
                        for (let i = 0; i < 2; i++) {
                            asteroids.push(
                                new Asteroid(asteroid.x, asteroid.y, newRadius, asteroid.level + 1, asteroid.color)
                            );
                        }
                    }

                    asteroids.splice(aIndex, 1);
                }
            });
        });

        // Blobs and asteroids collision
        blobs.forEach((blob) => {
            asteroids.forEach((asteroid) => {
                if (
                    distanceBetweenPoints(blob.x, blob.y, asteroid.x, asteroid.y) <
                    blob.radius + asteroid.radius
                ) {
                    // Change asteroid's direction based on blob's direction
                    let angle = Math.atan2(asteroid.y - blob.y, asteroid.x - blob.x);
                    asteroid.vx = Math.cos(angle) * asteroid.speed;
                    asteroid.vy = Math.sin(angle) * asteroid.speed;
                }
            });
        });

        // Asteroids and Enemy Ships collision
        asteroids.forEach((asteroid, aIndex) => {
            enemyShips.forEach((enemyShip, esIndex) => {
                if (
                    distanceBetweenPoints(asteroid.x, asteroid.y, enemyShip.x, enemyShip.y) <
                    asteroid.radius + enemyShip.radius
                ) {
                    // Optional: Remove or reduce the asteroid
                    if (asteroid.level < 3) {
                        let newRadius = asteroid.radius / 2;
                        for (let i = 0; i < 2; i++) {
                            asteroids.push(
                                new Asteroid(asteroid.x, asteroid.y, newRadius, asteroid.level + 1, asteroid.color)
                            );
                        }
                    }
                    asteroids.splice(aIndex, 1); // Remove the asteroid

                    // Handle enemy ship destruction
                    handleEnemyShipDestruction(esIndex, enemyShip.x, enemyShip.y);
                }
            });
        });

        // Blobs and Enemy Ships collision
        blobs.forEach((blob) => {
            enemyShips.forEach((enemyShip, esIndex) => {
                if (
                    distanceBetweenPoints(blob.x, blob.y, enemyShip.x, enemyShip.y) <
                    blob.radius + enemyShip.radius
                ) {
                    // Handle enemy ship destruction
                    handleEnemyShipDestruction(esIndex, enemyShip.x, enemyShip.y);
                }
            });
        });

        // Bullets and Enemy Ships collision
        bullets.forEach((bullet, bIndex) => {
            enemyShips.forEach((enemyShip, esIndex) => {
                if (
                    distanceBetweenPoints(bullet.x, bullet.y, enemyShip.x, enemyShip.y) <
                    bullet.radius + enemyShip.radius
                ) {
                    // Remove the player bullet
                    bullets.splice(bIndex, 1);

                    // Handle enemy ship destruction
                    handleEnemyShipDestruction(esIndex, enemyShip.x, enemyShip.y);

                    // Optional: Play a different sound for destroying enemy ships
                    // enemyDestructionSound.currentTime = 0;
                    // enemyDestructionSound.play().catch(error => {
                    //     console.error("Enemy destruction sound playback failed:", error);
                    // });
                }
            });
        });

        // Check if all asteroids and enemy ships are destroyed
        if (asteroids.length === 0 && explosions.length === 0 && enemyShips.length === 0 && !shipDestroyed) {
            // Stop ambient sound
            ambientSound.pause();

            round++;
            if (round > stories.length) {
                round = 1; // Reset to round 1 if stories are exhausted
            }
            inStoryMode = true;
            currentStoryPage = 0;
            storyTextDiv.style.display = 'block';
            canvas.style.display = 'none';
            displayStory();
            createAsteroids(round);
            if (round >= enemyShipStartRound) {
                createEnemyShips(round % 2); // Spawn enemy ships in the new round if applicable
            }
            if (round >= blobStartRound) {
                createBlobs(round % 2);
            }
        }
    }

    function draw() {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw round number
        ctx.fillStyle = CRT_GREEN;
        ctx.font = '20px Courier New';
        ctx.fillText('Round: ' + round, 20, 30);

        // Draw ship
        ship.draw();

        // Draw bullets
        bullets.forEach((bullet) => {
            bullet.draw();
        });

        // Draw enemy bullets
        enemyBullets.forEach((enemyBullet) => {
            enemyBullet.draw();
        });

        // Draw asteroids
        asteroids.forEach((asteroid) => {
            asteroid.draw();
        });

        // Draw enemy ships
        enemyShips.forEach((enemyShip) => {
            enemyShip.draw();
        });

        // Draw blobs
        blobs.forEach((blob) => {
            blob.draw();
        });

        // Draw explosions
        explosions.forEach((explosion) => {
            explosion.draw();
        });
    }

    function keyDown(e) {
        keys[e.key] = true;

        if (inStoryMode) {
            if (e.key === ' ') {
                displayStory();
            }

            if (e.key.toLowerCase() === 's') {
                // Skip the story and start the round
                inStoryMode = false;
                storyTextDiv.style.display = 'none';
                storyInstructionsDiv.style.display = 'none';
                canvas.style.display = 'block';

                // Play ambient sound
                ambientSound.currentTime = 0;
                ambientSound.play().catch(error => {
                    console.error("Ambient sound playback failed:", error);
                });
            }

            // Prevent default behavior for spacebar and 's' key
            if (e.key === ' ' || e.key.toLowerCase() === 's') {
                e.preventDefault();
            }

        } else if (ship.alive) {
            // Shoot bullet
            if (e.key === ' ') {
                bullets.push(new Bullet(ship.x, ship.y, ship.angle));

                // Play laser sound
                laserSound.currentTime = 0;
                laserSound.play().catch(error => {
                    console.error("Laser sound playback failed:", error);
                });
            }

            // Play ship bridge sound only when rotating
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                // To prevent multiple sounds from overlapping, check if the sound is already playing
                if (bridgeSound.paused) {
                    bridgeSound.currentTime = 0;
                    bridgeSound.play().catch(error => {
                        console.error("Bridge sound playback failed:", error);
                    });
                }
            }

            // Prevent default behavior for arrow keys and spacebar
            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', ' '].includes(e.key)) {
                e.preventDefault();
            }
        }
    }

    function keyUp(e) {
        keys[e.key] = false;

        // Stop bridge sound when arrow keys are released
        if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
            stopBridgeSound();
        }
    }

    function distanceBetweenPoints(x1, y1, x2, y2) {
        return Math.hypot(x1 - x2, y1 - y2);
    }

    // Function to create an explosion at a given position
    function createExplosion(x, y, radius, color = CRT_GREEN) {
        let numParticles = 20;
        let colors = [color, '#00CC00', '#009900']; // Shades based on collision type
        for (let i = 0; i < numParticles; i++) {
            let particleColor = colors[Math.floor(Math.random() * colors.length)];
            explosions.push(new Particle(x, y, particleColor));
        }
    }

    // Function to handle ship destruction
    function handleShipDestruction() {
        ship.alive = false;
        shipDestroyed = true;

        // Stop ambient sound
        ambientSound.pause();

        // Play ship explosion sound
        shipExplosionSound.currentTime = 0;
        shipExplosionSound.play().catch(error => {
            console.error("Ship explosion sound playback failed:", error);
        });

        // Create explosion at ship's position
        createExplosion(ship.x, ship.y, ship.radius, CRT_RED);

        // Set timeout to reset the game after 5 seconds
        setTimeout(() => {
            resetGame();
        }, 5000);
    }

    // Function to handle enemy ship destruction
    function handleEnemyShipDestruction(esIndex, x, y) {
        console.log(`Enemy Ship at (${x.toFixed(2)}, ${y.toFixed(2)}) destroyed`);
        // Remove the enemy ship from the array
        enemyShips.splice(esIndex, 1);

        // Create explosion at the enemy ship's position with a different color
        createExplosion(x, y, 20, CRT_RED); // Red explosions for enemy ships

        // Play explosion sound (you can use the existing explosionSound or a different one)
        explosionSound.currentTime = 0;
        explosionSound.play().catch(error => {
            console.error("Explosion sound playback failed:", error);
        });
    }

    // Function to reset the game after ship destruction
    function resetGame() {
        ship = new Ship();
        shipDestroyed = false;
        asteroids = [];
        bullets = [];
        enemyShips = []; // Clear enemy ships
        enemyBullets = []; // Clear enemy bullets
        explosions = [];
        blobs = []; // Clear existing blobs
        round = 1;
        inStoryMode = true;
        currentStoryPage = 0;
        storyTextDiv.style.display = 'block';
        canvas.style.display = 'none';
        displayStory();
        createAsteroids(round);
        if (round >= enemyShipStartRound) {
            createEnemyShips(round % 2); // Spawn enemy ships in the reset round if applicable
        }
        if (round >= blobStartRound) {
            createBlobs(round % 2);
        }
    }

    // Function to play bridge sound
    function playBridgeSound() {
        if (!bridgeSound.playing && !bridgeSound.paused) return;
        if (bridgeSound.paused) {
            bridgeSound.currentTime = 0;
            bridgeSound.play().catch(error => {
                console.error("Bridge sound playback failed:", error);
            });
        }
    }

    // Function to stop bridge sound
    function stopBridgeSound() {
        bridgeSound.pause();
    }

    // Start the game after the window has fully loaded
    window.addEventListener('load', () => {
        init();
    });
</script>
</body>
</html>
